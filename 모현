인터프리터는 프로그래밍 언어의 소스 코드를 바로 실행하는 컴퓨터 프로그램 또는 환경을 말한다. 
인터프리터는 다음의 과정 가운데 적어도 한 가지 기능을 가진 프로그램이다.
소스 코드를 직접 실행한다.
소스 코드를 효율적인 다른 중간 코드로 변환하고, 변환한 것을 바로 실행한다
인터프리터 시스템의 일부인 컴파일러가 만든, 미리 컴파일된[1] 저장 코드의 실행을 호출한다.
인터프리터는 고급 언어로 작성된 원시코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 프로그램이다. 
고급언어로 작성된 프로그램들을 실행하는 데에는 두 가지 방법이 있다. 
가장 일반적인 방법은 프로그램을 컴파일 하는 것이고, 다른 하나는 프로그램을 인터프리터에 통과시키는 방법이다. 
인터프리터는 고급 명령어들을 중간 형태로 번역한 다음, 그것을 실행한다.
컴파일된 프로그램들은 일반적으로 인터프리터를 이용해 실행시키는 것보다 더 빠르게 실행된다. 
그러나 인터프리터의 장점은 기계어 명령어들이 만들어지는 컴파일 단계를 거칠 필요가 없다는데 있다. 
컴파일 과정은 만약 원시 프로그램의 크기가 크다면, 상당한 시간이 걸릴 수 있다. 
이와는 달리 인터프리터는 고급 프로그램을 즉시 실행시킬 수 있다. 
이런 이유 때문에, 인터프리터는 종종 프로그램의 개발단계에서 사용되는데, 그것은 프로그래머가 한번에 적은 양의 내용을 추가하고 그것을 빠르게 테스트 해보길 원하기 때문이다. 
이 외에도 인터프리터를 이용하면 프로그래밍을 대화식으로 할 수 있기 때문에, 학생들의 교육용으로 사용되는 경우도 많다.
인터프리터는 고급언어에 적용이 가능하지만 BASIC 이나 LISP과 같은 일부 언어들은 개발 당시에는 특별히 인터프리터에 의해서만 실행되도록 설계되었다. 
그 외에도 포스트스크립트와 같은 페이지 기술 언어 들도 인터프리터를 사용한다. 
모든 포스트스크립트 프린터는 포스트스크립트 명령문을 실행할 수 있도록 인터프리터가 내장되어 있다.

https://ko.wikipedia.org/wiki/%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0#%EC%A2%85%EB%A5%98


컴파일러는 어셈블리어(기계어와 일대일 대응이 되는 컴퓨터 프로그래밍의 저급 언어)를 사용하는 초기 컴퓨터 프로그램의 문제점을 보완하기 위해 등장하였다.
컴파일러는 고급언어를 저급언어로 옯기는 역할을 수행한다. 옮기는 과정에서 반드시 지키는 두 가지의 조건이 있다.
1. 컴파일러는 언옮김의 과정에서 프로그램의 뜻을 보존해야 한다. 입력받은 프로그램의 의미를 충실히 따라 저급언어로 옮겨야 한다.
2. 실용적인 면에서, 컴파일러는 입력으로 들어온 프로그램을 어떤면에서든지 개선해야 한다.
컴파일러는 성능이 우수하고 오류를 검출할 수 있으며 초기 컴퓨터 프로그램에 비해 실행 속도가 빠르다는 장점이 있다. 
하지만 큰 프로젝트일 경우 컴파일 시간이 길고 메모리 사용량이 크다는 단점이 있으며 다른 환경에 이식하는 데 어려움이 있다는 것이다.






https://velog.io/@yonghyeun/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC-%EC%96%B8%EC%96%B4%EC%99%80-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EC%96%B8%EC%96%B4

20240919



https://velog.io/@cndbstlr7/%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EA%B8%B0%EC%B4%88-1.-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0

20240924



#파이선 코드로 바꿔주는(?)함수
def transpile(lines):    #lines는 새로운 언어 코드가 들어있는 리스트(코드 한 줄=리스트 값 하나)
    python_lines = []   #파이선으로 바뀐 코드를 저장할 리스트
    for line in lines:     #위에 lines(새로운언어 코드 리스트)의 한 줄식 순회(반복)함
        stripped_line = line.strip()  #strip은 앞뒤 공백을 제거해주는거

        if stripped_line.startswith('#'):   #만약 코드가 #으로 시작하면 
            continue                        #무시하고 지나가 ㄱㄱ

        elif stripped_line.startswith('set '):   #만약 코드가 set으로 시작되면
            python_line = stripped_line[4:]      #5번째 글자부터 파이선 코드로 저장(set 빼고)
            python_lines.append(python_line)

        elif stripped_line.startswith('print '):  #만약 코드가 print로 시작하면
            expression = stripped_line[6:]        #print+공백 뒤 7번째 글자부터 expression에 저장
            python_line = f"print({expression})"  #파이선 코드 리스트에 print(expression)형태로 저장
            python_lines.append(python_line)      

        else:     
            continue
    return '\n'.join(python_lines)


def execute_python_code(python_code):    #파이선 코드로 실행-->결과
    exec(python_code)

#대충 이런 언어가 있다고 쳐보자
code_lines = [
        "# 변수에 값 할당",
        "set x = 10",
        "set y = 20",
        "",
        "# x와 y의 합을 출력",
        "print x + y" ]
        
        
python_code = transpile(code_lines)   #위에서 만든 transpile함수로 코드 처리
print("파이썬 코드:")
print(python_code)    
print("실행 결과:")
execute_python_code(python_code)      #파이선 코드로 실행한 결과

















# 변환할 가상 언어의 코드 리스트를 파이썬 코드로 변환하는 함수
def transpile_to_python(custom_code):
    python_code = []
    indent_level = 0  # 들여쓰기 레벨을 관리하기 위한 변수
    
    for line in custom_code:
        stripped_line = line.strip()  # 각 코드 라인에서 공백 제거

        # 파이썬 코드에 들여쓰기를 추가하는 부분
        indent = "    " * indent_level
        
        if stripped_line.startswith("#"):  # 주석이면 무시
            continue

        elif stripped_line.startswith("set "):  # 'set'으로 시작하는 경우
            python_code.append(indent + stripped_line[4:])  # set을 제외한 나머지 추가

        elif stripped_line.startswith("print "):  # 'print'로 시작하는 경우
            expression = stripped_line[6:]  # print 이후 부분을 추출
            python_code.append(indent + f"print({expression})")

        elif stripped_line.startswith("repeat "):  # 반복문 'repeat'으로 시작하는 경우
            try:
                # repeat N times 를 파이썬의 for 문으로 변환
                repeat_count = int(stripped_line.split()[1])  # repeat 뒤의 숫자를 추출
                python_code.append(indent + f"for _ in range({repeat_count}):")
                indent_level += 1  # 반복문 내 코드는 들여쓰기 추가
            except (IndexError, ValueError):
                print("Error: 'repeat' 구문에서 반복 횟수를 찾을 수 없습니다.")

        elif stripped_line == "end":  # 반복문 종료 ('end' 키워드 처리)
            indent_level -= 1  # 들여쓰기 감소

        else:
            continue

    return "\n".join(python_code)

# 파이썬 코드 실행 함수
def execute_transpiled_code(python_code):
    exec(python_code)

# 가상의 언어로 작성된 코드 (코드 한 줄씩 리스트 형태로 입력)
custom_code = [
    "# 변수 할당",
    "set x = 1",
    "",
    "# 반복문 실행",
    "repeat 5",
    "print x",
    "set x = x + 1",
    "end"
]

# 변환 과정
transpiled_python_code = transpile_to_python(custom_code)

# 결과 출력
print("변환된 파이썬 코드:")
print(transpiled_python_code)
print("\n실행 결과:")
execute_transpiled_code(transpiled_python_code)
